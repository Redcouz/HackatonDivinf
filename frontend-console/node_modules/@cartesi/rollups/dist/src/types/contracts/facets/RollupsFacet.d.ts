import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../../common";
export interface RollupsFacetInterface extends utils.Interface {
    functions: {
        "claim(bytes32)": FunctionFragment;
        "finalizeEpoch()": FunctionFragment;
        "getChallengePeriod()": FunctionFragment;
        "getCurrentEpoch()": FunctionFragment;
        "getCurrentPhase()": FunctionFragment;
        "getInputAccumulationStart()": FunctionFragment;
        "getInputDuration()": FunctionFragment;
        "getSealingEpochTimestamp()": FunctionFragment;
        "getTemplateHash()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "claim" | "finalizeEpoch" | "getChallengePeriod" | "getCurrentEpoch" | "getCurrentPhase" | "getInputAccumulationStart" | "getInputDuration" | "getSealingEpochTimestamp" | "getTemplateHash"): FunctionFragment;
    encodeFunctionData(functionFragment: "claim", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "finalizeEpoch", values?: undefined): string;
    encodeFunctionData(functionFragment: "getChallengePeriod", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentEpoch", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentPhase", values?: undefined): string;
    encodeFunctionData(functionFragment: "getInputAccumulationStart", values?: undefined): string;
    encodeFunctionData(functionFragment: "getInputDuration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSealingEpochTimestamp", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTemplateHash", values?: undefined): string;
    decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "finalizeEpoch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getChallengePeriod", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentEpoch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentPhase", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInputAccumulationStart", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInputDuration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSealingEpochTimestamp", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTemplateHash", data: BytesLike): Result;
    events: {
        "Claim(uint256,address,bytes32)": EventFragment;
        "FinalizeEpoch(uint256,bytes32)": EventFragment;
        "PhaseChange(uint8)": EventFragment;
        "ResolveDispute(address,address,bytes32)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Claim"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FinalizeEpoch"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PhaseChange"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ResolveDispute"): EventFragment;
}
export interface ClaimEventObject {
    epochNumber: BigNumber;
    claimer: string;
    epochHash: string;
}
export type ClaimEvent = TypedEvent<[
    BigNumber,
    string,
    string
], ClaimEventObject>;
export type ClaimEventFilter = TypedEventFilter<ClaimEvent>;
export interface FinalizeEpochEventObject {
    epochNumber: BigNumber;
    epochHash: string;
}
export type FinalizeEpochEvent = TypedEvent<[
    BigNumber,
    string
], FinalizeEpochEventObject>;
export type FinalizeEpochEventFilter = TypedEventFilter<FinalizeEpochEvent>;
export interface PhaseChangeEventObject {
    newPhase: number;
}
export type PhaseChangeEvent = TypedEvent<[number], PhaseChangeEventObject>;
export type PhaseChangeEventFilter = TypedEventFilter<PhaseChangeEvent>;
export interface ResolveDisputeEventObject {
    winner: string;
    loser: string;
    winningClaim: string;
}
export type ResolveDisputeEvent = TypedEvent<[
    string,
    string,
    string
], ResolveDisputeEventObject>;
export type ResolveDisputeEventFilter = TypedEventFilter<ResolveDisputeEvent>;
export interface RollupsFacet extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: RollupsFacetInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        claim(_epochHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        finalizeEpoch(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getChallengePeriod(overrides?: CallOverrides): Promise<[BigNumber]>;
        getCurrentEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;
        getCurrentPhase(overrides?: CallOverrides): Promise<[number]>;
        getInputAccumulationStart(overrides?: CallOverrides): Promise<[BigNumber]>;
        getInputDuration(overrides?: CallOverrides): Promise<[BigNumber]>;
        getSealingEpochTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;
        getTemplateHash(overrides?: CallOverrides): Promise<[string]>;
    };
    claim(_epochHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    finalizeEpoch(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getChallengePeriod(overrides?: CallOverrides): Promise<BigNumber>;
    getCurrentEpoch(overrides?: CallOverrides): Promise<BigNumber>;
    getCurrentPhase(overrides?: CallOverrides): Promise<number>;
    getInputAccumulationStart(overrides?: CallOverrides): Promise<BigNumber>;
    getInputDuration(overrides?: CallOverrides): Promise<BigNumber>;
    getSealingEpochTimestamp(overrides?: CallOverrides): Promise<BigNumber>;
    getTemplateHash(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        claim(_epochHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        finalizeEpoch(overrides?: CallOverrides): Promise<void>;
        getChallengePeriod(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentEpoch(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentPhase(overrides?: CallOverrides): Promise<number>;
        getInputAccumulationStart(overrides?: CallOverrides): Promise<BigNumber>;
        getInputDuration(overrides?: CallOverrides): Promise<BigNumber>;
        getSealingEpochTimestamp(overrides?: CallOverrides): Promise<BigNumber>;
        getTemplateHash(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Claim(uint256,address,bytes32)"(epochNumber?: PromiseOrValue<BigNumberish> | null, claimer?: null, epochHash?: null): ClaimEventFilter;
        Claim(epochNumber?: PromiseOrValue<BigNumberish> | null, claimer?: null, epochHash?: null): ClaimEventFilter;
        "FinalizeEpoch(uint256,bytes32)"(epochNumber?: PromiseOrValue<BigNumberish> | null, epochHash?: null): FinalizeEpochEventFilter;
        FinalizeEpoch(epochNumber?: PromiseOrValue<BigNumberish> | null, epochHash?: null): FinalizeEpochEventFilter;
        "PhaseChange(uint8)"(newPhase?: null): PhaseChangeEventFilter;
        PhaseChange(newPhase?: null): PhaseChangeEventFilter;
        "ResolveDispute(address,address,bytes32)"(winner?: null, loser?: null, winningClaim?: null): ResolveDisputeEventFilter;
        ResolveDispute(winner?: null, loser?: null, winningClaim?: null): ResolveDisputeEventFilter;
    };
    estimateGas: {
        claim(_epochHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        finalizeEpoch(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        getChallengePeriod(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentEpoch(overrides?: CallOverrides): Promise<BigNumber>;
        getCurrentPhase(overrides?: CallOverrides): Promise<BigNumber>;
        getInputAccumulationStart(overrides?: CallOverrides): Promise<BigNumber>;
        getInputDuration(overrides?: CallOverrides): Promise<BigNumber>;
        getSealingEpochTimestamp(overrides?: CallOverrides): Promise<BigNumber>;
        getTemplateHash(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        claim(_epochHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        finalizeEpoch(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getChallengePeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentPhase(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getInputAccumulationStart(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getInputDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSealingEpochTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTemplateHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
